import numpy as np
from scipy import sparse
import pylibconfig2
import pymutt


def ccf(ts1, ts2, lagMax=None, sampFreq=1., norm=True):
    """ Cross-correlation function"""
    ts1 -= ts1.mean()
    ts2 -= ts2.mean()
    if norm:
        ts1 /= ts1.std()
        ts2 /= ts2.std()
    nt = ts1.shape[0]
    if lagMax is None:
        lagMax = nt - 1
    lagMaxSample = int(lagMax * sampFreq)
    ccf = np.empty((lagMaxSample*2+1,))
    for k in np.arange(lagMaxSample):
        ccf[k] = (ts1[:-(lagMaxSample-k)] * ts2[lagMaxSample-k:]).mean()
    ccf[lagMaxSample] = (ts1 * ts2).mean()
    for k in np.arange(lagMaxSample):
        ccf[2*lagMaxSample-k] = (ts2[:-(lagMaxSample-k)] \
                                 * ts1[lagMaxSample-k:]).mean()
    return ccf


def ccovf(ts1, ts2, lagMax=None):
    """ Cross-covariance function"""
    ts1 = ts1 - ts1.mean()
    ts2 = ts2 - ts2.mean()
    nt = ts1.shape[0]
    if lagMax is None:
        lagMax = nt - 1
    ccovf = np.empty((lagMax*2+1,))
    for k in np.arange(lagMax):
        ccovf[k] = (ts1[:-(lagMax-k)] * ts2[lagMax-k:]).mean()
    ccovf[lagMax] = (ts1 * ts2).mean()
    for k in np.arange(lagMax):
        ccovf[2*lagMax-k] = (ts2[:-(lagMax-k)] * ts1[lagMax-k:]).mean()
    return ccovf

def getPerio(ts1, ts2=None, freq=None, sampFreq=1., chunkWidth=None, norm=False, window=None):
    ''' Get the periodogram of ts using a taping window of length tape window'''
    nt = ts1.shape[0]
    if ts2 is None:
        ts2 = ts1.copy()

    # If no chunkWidth given then do not tape
    if chunkWidth is None:
        chunkWidthNum = nt
    else:
        chunkWidthNum = int(chunkWidth * sampFreq)
    if window is None:
        window = np.ones(chunkWidthNum)
        
    nChunks = int(nt / chunkWidthNum)

    # Get frequencies if not given
    if freq is None:
        freq = getFreqPow2(chunkWidth, sampFreq=sampFreq)
    nfft = freq.shape[0]

    # Remove mean [and normalize]
    ts1 -= ts1.mean(0)
    ts2 -= ts2.mean(0)

    # Get periodogram averages over nChunks windows
    perio = np.zeros((nfft,))
    perioSTD = np.zeros((nfft,))
    for tape in np.arange(nChunks):
        ts1Tape = ts1[tape*chunkWidthNum:(tape+1)*chunkWidthNum]
        ts1Windowed = ts1Tape * window
        ts2Tape = ts2[tape*chunkWidthNum:(tape+1)*chunkWidthNum]
        ts2Windowed = ts2Tape * window
        # Fourier transform and shift zero frequency to center
        fts1 = np.fft.fft(ts1Windowed, nfft, 0)
        fts1 = np.fft.fftshift(fts1)
        fts2 = np.fft.fft(ts2Windowed, nfft, 0)
        fts2 = np.fft.fftshift(fts2)
        # Get periodogram
        pt = (fts1 * np.conjugate(fts2)).real / chunkWidthNum / sampFreq
        perio +=  pt
        perioSTD += pt**2
    perio /= nChunks
    perioSTD = np.sqrt(perioSTD / nChunks)

    if norm:
        perio /= np.cov(ts1, ts2)[0, 1]
        perioSTD /= np.cov(ts1, ts2)[0, 1]

    return (freq, perio, perioSTD)

def getPowerMTM(ts1, sampFreq=1., nwin=5, norm=False):
    ''' Get the power spectrum using the Multi-Tapper Method'''
    nt = ts1.shape[0]

    # Remove mean [and normalize]
    ts1 -= ts1.mean(0)

    mt = pymutt.mtft(ts1, dt=1./sampFreq, nwin=nwin)
    freq = np.arange(mt['nspec']) * mt['df']
    power = mt['power']

    if norm:
        power /= np.cov(ts1, ts1)[0, 1]

    freqSym = np.concatenate((-freq[:0:-1], freq))
    powerSym = np.concatenate((power[:0:-1], power))

    return (freqSym, powerSym)

def getFreqPow2(L, sampFreq=1., center=True):
    ''' Get frequency vector with maximum span given by the closest power of 2 (fft) of the lenght of the times series nt'''
    nt = L * sampFreq
    # Get nearest larger power of 2
    if np.log2(nt) != int(np.log2(nt)):
        nfft = 2**(int(np.log2(nt)) + 1)
    else:
        nfft = nt

    # Get frequencies
    freq = np.fft.fftfreq(nfft, d=1./sampFreq)

    # Shift zero frequency to center
    if center:
        freq = np.fft.fftshift(freq)

    return freq

def getMIFromProb(P, initDist=None, finalDist=None):
    # Get distributions
    if initDist is None:
        initDist = P.sum(1)
    if finalDist is None:
        finalDist = P.sum(0)
        
    if sparse.issparse(P):
        pos = P.data > 0
        dataPos = P.data[pos]
        init = initDist[P.row[pos]]
        final = finalDist[P.col[pos]]
    else:
        pos = P > 0
        (I, J) = np.meshgrid(np.arange(P.shape[0]), np.arange(P.shape[1]), indexing='ij')
        dataPos = P[pos]
        init = initDist[I.flatten()]
        final = finalDist[J.flatten()]
    mi = np.sum(dataPos * np.log2(dataPos / (init*final)))

    return mi
    

def getMIFFromGridMemVect(gridMemVect, N, lagMax, sampFreq=1.,
                          step=None, verbose=False):
    nt = gridMemVect.shape[0]
    if step is None:
        step = 1. / sampFreq
    lagMaxSample = int(lagMax * sampFreq)
    nLags = int(lagMax / step) + 1
    mif = np.empty((nLags,))

    # Get stationary distribution
    if verbose:
        print 'Computing stationary distribution...'
    statDist = np.zeros((N,))
    for t in np.arange(nt):
        if gridMemVect[t] < N:
            statDist[gridMemVect[t]] += 1.
    statDist /= statDist.sum()

    # Get mutual information for each lag
    for lag in np.arange(nLags):
        lagSample = int(np.round(lag * step * sampFreq))
        if verbose:
            print 'Computing mutual information function for step ', \
                lag, '/', (nLags - 1)
        # Get and-transition matrix
        data, row, col = [], [], []
        for t in np.arange(nt - lagSample):
            if (gridMemVect[t] < N) & (gridMemVect[t + lagSample] < N):
                data.append(1.)
                row.append(gridMemVect[t])
                col.append(gridMemVect[t + lagSample])
        data = np.array(data, dtype=float)
        data /= data.sum()
        P = sparse.coo_matrix((data, (row, col)), (N, N), dtype=float)
        P.sum_duplicates()

        # Get mutual information
        mif[lag] = getMIFromProb(P, initDist=statDist, finalDist=statDist)

    return mif
