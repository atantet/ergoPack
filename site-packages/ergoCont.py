import numpy as np
from ergoInt import *

def Floquet(x0, field, Jac, p, scheme, dt, nt, backward=False):
    dim = x0.shape[0]
    # Integrate over a period T
    if backward:
        (xt, Mt) = propagateFundamentalRange(x0, field, Jac, p,
                                             scheme, dt, nt)
        MT = Mt[0]
    else:
        (xt, Mt) = propagateFundamental(x0, field, Jac,p, scheme, dt, nt)
        MT = Mt[-1]

    # Get eigen-elements of fundamental matrix
    (eigVal, eigVec) = np.linalg.eig(MT)
    # Sort eigen-elements
    isort = np.argsort(-np.abs(eigVal))
    eigVal = eigVal[isort]
    eigVec = eigVec[:, isort]
    
    # Solve adjoint eigen-problem
    (eigValLeft, eigVecLeft) = np.linalg.eig(MT.T)
    # Sort them by pairs
    tmpVal = eigValLeft.copy()
    tmpVec = eigVecLeft.copy()
    for d in np.arange(dim):
            idx = np.argmin(np.abs(eigVal[d] - np.conjugate(tmpVal)))
            eigValLeft[d] = tmpVal[idx]
            eigVecLeft[:, d] = tmpVec[:, idx]

    # Get Floquet exponents
    FloquetExp = np.log(eigVal) / (nt * dt)

    return (xt, Mt, FloquetExp, eigVec, eigVecLeft)


def getCovarianceMatrix(Qs, Mts, dt=1.):
    nt = Mts.shape[0] - 1
    dim = Mts[0].shape[0]
    
    # Get correlation matrix
    CT = np.zeros((dim, dim))
    for r in np.arange(nt):
        CT += np.dot(np.dot(Mts[r], Qs[r]), Mts[r].T)

    # Scale by time
    CT *= dt

    return CT


def getPhaseDiffusionFromCov(CT, vLeft, vRight, T=1.):
    phi = np.dot(np.dot(vLeft, CT), vLeft) \
          / np.dot(vLeft, vRight) / T

    return phi

    
def getPhaseDiffusion(Qs, Mts, vLeft, vRight, dt=1.):
    nt = Mts.shape[0] - 1
    T = dt * nt
    
    # Get covariance matrix
    CT = getCovarianceMatrix(Qs, Mts, dt)

    # Get phase diffusion
    phi = getPhaseDiffusionFromCov(CT, vLeft, vRight, T)
        
    return phi

            
