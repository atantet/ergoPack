import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm, patches
from matplotlib.collections import PatchCollection
from matplotlib.colors import LogNorm
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.collections import PolyCollection
import pylibconfig2

# Default parameters
levels = 20
levelsPhase = 13
levelsAmp = 6
fs_default = 'x-large'
fs_latex = 'xx-large'
fs_xlabel = fs_default
fs_ylabel = fs_default
fs_xticklabels = fs_default
fs_yticklabels = fs_default
fs_zticklabels = fs_default
fs_legend_title = fs_default
fs_legend_labels = fs_default
fs_cbar_label = fs_default
fs_clabel = 'large'
figFormat = 'eps'
#figFormat = 'png'
dpi = 300
msize = 32
lw = 2
bbox_inches = 'tight'
plt.rc('font',**{'family':'serif'})

#############
# Definitions
#############

def readSpectrum(eigValForwardFile=None, eigValBackwardFile=None,
                 eigVecForwardFile=None, eigVecBackwardFile=None,
                 statDist=None,
                 makeBiorthonormal=False, fileFormat="bin"):
    """Read transfer operator spectrum from file and create \
    a bi-orthonormal basis of eigenvectors and adjoint eigenvectors. \
    If nev is given, only the first nev vectors are read. \
    They should be sorted before."""

    ret = ()
    isortBackward = None
    
    # Read eigenvalues and make complex
    if eigValForwardFile is not None:
        if fileFormat == 'bin':
            eigValForward = np.fromfile(eigValForwardFile, complex)
        else:
            eigValForward = np.loadtxt(eigValForwardFile)
            eigValForward = eigValForward[:, 0] + 1j*eigValForward[:, 1]
        nevForward = eigValForward.shape[0]
        nev = nevForward
    
        # Sort by largest magnitude
        if makeBiorthonormal:
            isortForward = np.argsort(-np.abs(eigValForward))
            eigValForward = eigValForward[isortForward]

    # Same for backward eigenvalues
    if eigValBackwardFile is not None:
        # Read eigenvalues and make complex
        if fileFormat == 'bin':
            eigValBackward = np.fromfile(eigValBackwardFile, complex)
        else:
            eigValBackward = np.loadtxt(eigValBackwardFile)
            eigValBackward = eigValBackward[:, 0] + 1j*eigValBackward[:, 1]
        nevBackward = eigValBackward.shape[0]

        # Get common indices (after and before sorting for the
        # forward and backward eigenvalues, respectively)
        if eigValForwardFile is not None:
            (idFor, idBack) = intersect(eigValForward, eigValBackward,
                                        compComplex, tol=1.e-6)
            eigValForward = eigValForward[idFor]
            eigValBackward = eigValBackward[idBack]
            nev = eigValForward.shape[0]

        # Because different eigenvalues may have the same magnitude
        # sort the adjoint eigenvalues by correspondance to the eigenvalues.
        if (eigValForwardFile is not None) and makeBiorthonormal:
            isortBackward = np.empty((nev,), int)
            for ev in np.arange(nev):
                isortBackward[ev] \
                    = np.argmin(np.abs(eigValForward[ev]
                                       - np.conjugate(eigValBackward)))
            eigValBackward = eigValBackward[isortBackward]

    # Pack return tuple with forward eigenvalue
    if eigValForwardFile is not None:
        ret += (eigValForward,)

        # Pack return tuple with backward eigenvalue
    if eigValBackwardFile is not None:
        ret += (eigValBackward,)

    # Read forward eigenvectors
    if eigVecForwardFile is not None:
        if fileFormat == 'bin':
            eigVecForward = np.fromfile(eigVecForwardFile, complex)
        else:
            eigVecForward = np.loadtxt(eigVecForwardFile)
            eigVecForward = eigVecForward[:, 0] + 1j*eigVecForward[:, 1]
        eigVecForward = eigVecForward.reshape(nevForward, -1)
        
        # Sort
        if makeBiorthonormal:
            eigVecForward = eigVecForward[isortForward]
            eigVecForward[0] = np.abs(eigVecForward[0]) \
                               / np.max(np.abs(eigVecForward[0]))

        # Select intersection (after sorting)
        if eigValBackwardFile is not None:
            eigVecForward = eigVecForward[idFor]

        ret += (eigVecForward,)

    # Read backward eigenvectors 
    if eigVecBackwardFile is not None:
        if fileFormat == 'bin':
            eigVecBackward = np.fromfile(eigVecBackwardFile, complex)
        else:
            eigVecBackward = np.loadtxt(eigVecBackwardFile)
            eigVecBackward = eigVecBackward[:, 0] + 1j*eigVecBackward[:, 1]
        eigVecBackward = eigVecBackward.reshape(nevBackward, -1)

        # Select intersection (before sorting)
        if (eigValForwardFile is not None) \
           and (eigValBackwardFile is not None):
            eigVecBackward = eigVecBackward[idFor]

        # Sort
        if (eigVecForwardFile is not None) and makeBiorthonormal:
            eigVecBackward = eigVecBackward[isortBackward]

            if eigVecForwardFile is None:
                print('File for reading forward eigenvectors should be given to contruct biorthonormal basis.')
            else:
                # If stationary distribution file not given
                # then forward eigenvectors assumed Lebesgue
                if statDist is None:
                    N = eigVecForward.shape[1]
                    statDist = np.ones((N,), dtype=float)
                # Normalize adjoint eigenvectors to have bi-orthonormal basis
                for ev in np.arange(nev):
                    norm = np.sum(np.conjugate(eigVecBackward[ev]) \
                                  * statDist * eigVecForward[ev])
                    eigVecBackward[ev] /= np.conjugate(norm)
        ret += (eigVecBackward,)

    return ret

def sortEigenvectors(eigValForward, eigValBackward,
                     eigVecForward, eigVecBackward,
                     sort='LM'):
    """Sort eigenvalues and eigenvectors and make adjoint to correspond"""
    nev, N = eigVecForward.shape
    # Sort forward eigenvalues and eigenvectors
    if sort[0] in ('L', 'l'):
        sgn = -1
    elif sort[0] in ('S', 's'):
        sgn = 1
    else:
        print('sort option should start with an [L, l]argest or [S, s]mallest')
    if sort[1] == 'M':
        isortForward = np.argsort(sgn * np.abs(eigValForward))
    elif sort[1] == 'R':
        isortForward = np.argsort(sgn * np.real(eigValForward))
    elif sort[1] == 'I':
        isortForward = np.argsort(sgn * np.imag(eigValForward))
    eigValForward = eigValForward[isortForward]
    eigVecForward = eigVecForward[isortForward]

    # Sort backward eigenvalues and eigenvectors
    # Because different eigenvalues may have the same magnitude
    # sort the adjoint eigenvalues by correspondance to the eigenvalues.
    isortBackward = np.empty((nev,), dtype=int)
    for ev in np.arange(nev):
        isortBackward[ev] = np.argmin(np.abs(eigValForward[ev] \
                                             - np.conjugate(eigValBackward)))
    eigValBackward = eigValBackward[isortBackward]
    eigVecBackward = eigVecBackward[isortBackward]

    return (eigValForward, eigValBackward, eigVecForward, eigVecBackward)


def makeBiorthonormal(eigVecForward, eigVecBackward, statDist=None):
    """Take two family of biorthogonal vectors and make them a biorthonormal,
by normalizing the second"""
    nev, N = eigVecForward.shape
    if statDist is None:
        statDist = np.ones((N,), dtype=float)
        eigVecForward /= np.sum(eigVecForward[0].real)
    for ev in np.arange(nev):
        norm = np.sum(np.conjugate(eigVecBackward[ev]) * statDist \
                      * eigVecForward[ev])
        eigVecBackward[ev] /= np.conjugate(norm)

    return (eigVecForward, eigVecBackward)
    


def readSpectrumGenerator(nev, N, eigValForwardFile, eigVecForwardFile,
                          eigValBackwardFile, eigVecBackwardFile,
                          readVectors=True, makeBiorthonormal=False):
    """Read transfer operator spectrum from file and create a bi-orthonormal basis \
    of eigenvectors and adjoint eigenvectors"""

    # Read eigenvalues
    eigValForward = np.empty((nev,), dtype=complex)
    loadtxt_complex(eigValForwardFile, eigValForward)
    eigValBackward = np.empty((nev,), dtype=complex)
    loadtxt_complex(eigValBackwardFile, eigValBackward)

    # Sort by largest magnitude
    isortForward = np.argsort(-eigValForward.real)
    eigValForward = eigValForward[isortForward]
    
    # Because different eigenvalues may have the same magnitude
    # sort the adjoint eigenvalues by correspondance to the eigenvalues.
    isortBackward = np.empty((nev,), dtype=int)
    for ev in np.arange(nev):
        isortBackward[ev] = np.argmin(np.abs(eigValForward[ev] \
                                             - np.conjugate(eigValBackward)))
    eigValBackward = eigValBackward[isortBackward]
            
    if readVectors:
        # Read eigenvectors
        eigVecForward = np.empty((N, nev), dtype=complex)
        loadtxt_complex(eigVecForwardFile, eigVecForward)
        eigVecForward = eigVecForward.T
        eigVecBackward = np.empty((N, nev), dtype=complex)
        loadtxt_complex(eigVecBackwardFile, eigVecBackward)
        eigVecBackward = eigVecBackward.T

        # Sort
        eigVecForward = eigVecForward[isortForward]
        eigVecBackward = eigVecBackward[isortBackward]

        # Get stationary distribution
        statDist = eigVecForward[0].real.copy()
        statDist /= statDist.sum()

        if makeBiorthonormal:
            # Normalize adjoint eigenvectors to have a bi-orthonormal basis
            for ev in np.arange(nev):
                norm = np.sum(eigVecForward[ev] * \
                              np.conjugate(eigVecBackward[ev]))
                eigVecBackward[ev] /= np.conjugate(norm)
        return (eigValForward, eigVecForward, eigValBackward, eigVecBackward,
                statDist)
    else:
        return (eigValForward, eigValBackward)


def readSpectrumCompressed(eigValForwardFile=None, eigValBackwardFile=None,
                           eigVecForwardFile=None, eigVecBackwardFile=None,
                           statDist=None, makeBiorthonormal=False):
    """Read transfer operator spectrum from file and create \
    a bi-orthonormal basis of eigenvectors and adjoint eigenvectors"""

    skiprows = 2
    ret = ()
    isortBackward = None
    
    # Read eigenvalues
    if eigValForwardFile is not None:
        eigValForwardCmp = np.loadtxt(eigValForwardFile)
        nev = eigValForwardCmp.shape[0]
        # Make complex
        eigValForward = eigValForwardCmp[:, 0] \
                        + 1j*eigValForwardCmp[:, 1]
        indexForward = eigValForwardCmp[:, 2]
        # Sort by largest magnitude
        isortForward = np.argsort(np.abs(eigValForward))[::-1]
        eigValForward = eigValForward[isortForward]
        ret += (eigValForward,)
    
    if eigValBackwardFile is not None:
        # Read eigenvalues
        eigValBackwardCmp = np.loadtxt(eigValBackwardFile)
        nev = eigValBackwardCmp.shape[0]
        # Make complex
        eigValBackward = eigValBackwardCmp[:, 0] \
                         + 1j*eigValBackwardCmp[:, 1]  # P = E^{-1} \Lambda E
        indexBackward = eigValBackwardCmp[:, 2]

        if eigValForwardFile is not None:
            # Because different eigenvalues may have the same magnitude sort
            # the adjoint eigenvalues by correspondance to the eigenvalues.
            isortBackward = np.empty((nev,), dtype=int)
            for ev in np.arange(nev):
                isortBackward[ev] \
                    = np.argmin(np.abs(eigValForward[ev] \
                                       - np.conjugate(eigValBackward)))
            eigValBackward = eigValBackward[isortBackward]
        ret += (eigValBackward,)

    # Read eigenvectors
    if eigVecForwardFile is not None:
        eigVecForwardCmp = np.loadtxt(eigVecForwardFile,
                                      skiprows=skiprows).reshape(nev, -1).T
        N = eigVecForwardCmp.shape[0]
        # Get full forward vectors
        eigVecForward = np.empty((N, nev), dtype=complex)
        for ev in np.arange(nev):
            if indexForward[ev] == 0:
                eigVecForward[:, ev] = eigVecForwardCmp[:, ev]
            elif indexForward[ev] == 1:
                eigVecForward[:, ev] = eigVecForwardCmp[:, ev] \
                                       + 1j*eigVecForwardCmp[:, ev+1]
            elif indexForward[ev] == -1:
                eigVecForward[:, ev] = eigVecForwardCmp[:, ev - 1] \
                                       - 1j*eigVecForwardCmp[:, ev]
            # Sort 
            eigVecForward = eigVecForward[:, isortForward]

    if eigVecBackwardFile is not None:
        eigVecBackwardCmp = np.loadtxt(eigVecBackwardFile,
                                       skiprows=skiprows).reshape(nev, -1).T
        N = eigVecBackwardCmp.shape[0]
        # Get full forward vectors
        eigVecBackward = np.empty((N, nev), dtype=complex)
        ev = 0
        for ev in np.arange(nev):
            if indexBackward[ev] == 0:
                eigVecBackward[:, ev] = eigVecBackwardCmp[:, ev]
            elif indexBackward[ev] == 1:
                eigVecBackward[:, ev] = eigVecBackwardCmp[:, ev] \
                                        + 1j*eigVecBackwardCmp[:, ev+1]
            elif indexBackward[ev] == -1:
                eigVecBackward[:, ev] = eigVecBackwardCmp[:, ev - 1] \
                                        - 1j*eigVecBackwardCmp[:, ev]
            # Sort
            if isortBackward is not None:
                eigVecBackward = eigVecBackward[:, isortBackward]
        
    if ((eigVecForwardFile is not None) & (eigVecBackwardFile is not None)
        & makeBiorthonormal):
        # Normalize adjoint eigenvectors to have a bi-orthonormal basis
        for ev in np.arange(nev):
            norm = np.sum(np.conjugate(eigVecBackward[:, ev]) * statDist \
                          * eigVecForward[:, ev])
            eigVecBackward[:, ev] /= np.conjugate(norm)
    if eigVecForwardFile is not None:
        ret += (eigVecForward,)
    if eigVecBackwardFile is not None:
        ret += (eigVecBackward,)

    return ret


def eig2Generator(eigVal, tau, eigValUnfold=None, tauUnfold=None):
    nev = eigVal.shape[0]
    # Associate each unfolding eigenvalue to an eigenvalue
    unfold = False
    if (eigValUnfold is not None) & (tauUnfold is not None):
        unfold = True

    eigValGen = np.empty((nev,), dtype=complex)
    eigValGen[:] = np.log(np.abs(eigVal)) / tau
    if unfold:
        eigValGen += 1j * np.angle(eigValUnfold / eigVal) / (tauUnfold - tau)
    else:
        eigValGen += 1j * np.angle(eigVal) / tau

    return eigValGen


def getSpectralWeights(f, g, eigVecForward, eigVecBackward, statDist=None):
    """Calculate the spectral weights as the product of \
the scalar products of the observables on eigenvectors \
and adjoint eigenvectors w.r.tw the stationary distribution.
If the latter is not given, then the forward eigenvectors are assumed to cary it."""
    nev, N = eigVecForward.shape
    # Get stationary distribution
    if statDist is None:
        statDist = eigVecForward[0].real
        statDist /= statDist.sum()
        forwardLebesgue = True
    else:
        forwardLebesgue = False
    
    # Get weights
    weights = np.zeros((nev,), dtype=complex)
    for ev in np.arange(nev):
        weights[ev] = (f * statDist * np.conjugate(eigVecBackward[ev])).sum()
        if forwardLebesgue:
            weights[ev] *= (eigVecForward[ev] * np.conjugate(g)).sum()
        else:
            weights[ev] *= (eigVecForward[ev] * statDist \
                            * np.conjugate(g)).sum()
            
    return weights

def spectralRecCorrelation(lags, eigValGen, weights, norm=False):
    """Calculate the reconstruction of the correlation function \
from the spectrum of the generator"""
    nev = eigValGen.shape[0]
    components = np.zeros((nev, lags.shape[0]), dtype=complex)
    for ev in np.arange(1, nev):
        # These are left eigenvalues, so no conjugate!
        components[ev] = np.exp(eigValGen[ev] * np.abs(lags)) * weights[ev]
    reconstruction = components.sum(0).real
    
    # Normalize
    if norm:
        cov = np.sum(weights[1:]).real
        reconstruction /= cov
        components /= cov


    return (reconstruction, components)

def spectralRecPower(angFreq, eigValGen, weights, norm=False):
    """Calculate the reconstruction of the power spectrum \
from the spectrum of the generator"""
    nev = eigValGen.shape[0]
    components = np.zeros((nev, angFreq.shape[0]), dtype=complex)
    for ev in np.arange(1, nev): 
        if np.abs(eigValGen[ev].real) > 1.e-6:
            components[ev] = -weights[ev] / np.pi * eigValGen[ev].real \
                            / ((angFreq - eigValGen[ev].imag)**2 \
                               + eigValGen[ev].real**2)
        else:
            components[ev] = 0.
    reconstruction = components.sum(0).real

    if norm:
        cov = np.sum(weights[1:]).real
        reconstruction /= cov
        components /= cov
        
    return (reconstruction, components)

def regressWeightsFromCorr(lags, corrSample, eigValGen):
    nLags = lags.shape[0]
    lags = lags[(nLags - 1) // 2:]
    corrSample = corrSample[(nLags - 1) // 2:]
    
    nev, nLags = eigValGen.shape[0], lags.shape[0]
    X = np.empty((nLags, nev-1), dtype=complex)
    for ev in np.arange(1, nev):
        X[:, ev-1] = np.exp(eigValGen[ev] * lags)
    X = np.matrix(X)
    weights = (X.T * X)**(-1) * (X.T * np.matrix(corrSample).T)
    
    return np.concatenate(([0], np.array(weights)[:, 0]))
    
def regressWeightsFromCorr2(lags, corrSample, eigValGen):
    nLags = lags.shape[0]
    lags = lags[(nLags - 1) // 2:]
    corrSample = corrSample[(nLags - 1) // 2:]

    
    
    nev, nLags = eigValGen.shape[0], lags.shape[0]
    X = np.empty((nLags, nev-1), dtype=complex)
    for ev in np.arange(1, nev):
        X[:, ev-1] = np.exp(eigValGen[ev] * lags)
    X = np.matrix(X)
    weights = (X.T * X)**(-1) * (X.T * np.matrix(corrSample).T)
    
    return np.concatenate(([0], np.array(weights)[:, 0]))
    
def regressWeightsFromPower(angFreq, powerSample, eigValGen):
    nev = eigValGen.shape[0]
    X = np.empty((angFreq.shape[0], nev-1), dtype=complex)
    for ev in np.arange(1, nev):
        X[:, ev-1] = -eigValGen[ev].real / np.pi \
                     / ((angFreq - eigValGen[ev].imag)**2 \
                        + eigValGen[ev].real**2)                    
    X = np.matrix(X)
    weights = (X.T * X)**(-1) * (X.T * np.matrix(powerSample).T)
    
    return np.concatenate(([0], np.array(weights)[:, 0]))
    
def plotEigVec(Xt, Yt, vectOrig, mask=None, xlabel=r'$x$', ylabel=r'y',
               alpha=0., cmap=cm.RdBu_r, positive=False):
    '''X and Y matrices given in indices order (not xy)!'''
    fig = plt.figure()
    ax = fig.add_subplot(111)
    vect = vectOrig.copy()
    vecAlpha = vect[vect != 0]
    if positive:
        vect /= vect.sum()
    vecAlpha = vect[vect != 0]
    if alpha > 1.e-6:
        if positive:
            vmax = np.sort(vecAlpha)[int((1. - alpha) \
                                         * vecAlpha.shape[0])-1]
            vmin = 0.
        else:
            vmax = np.sort(np.abs(vecAlpha))[int((1. - 2*alpha) \
                                                 * vecAlpha.shape[0])-1]
            vmin = -vmax
        vect[vect > vmax] = vmax
        vect[vect < vmin] = vmin
    else:
        if positive:
            vmax = np.max(vect)
            vmin = 0.
        else:
            vmax = np.max(np.abs(vect))
            vmin = -vmax
    if not positive:
        vect /= np.abs(vmax)
        vmax /= np.abs(vmax)
        vmin /= np.abs(vmin)
    
    # Draw collection of boxes
    (X, Y) = (Xt.T, Yt.T)
    if mask is not None:
        (dx, dy) = (X[0, 1] - X[0, 0], Y[1, 0] - Y[0, 0])
        N = mask.shape[0]
        coord = (Xt.flatten()[mask < N], Yt.flatten()[mask < N])
        p = pcolor_rectangle(coord[0], coord[1], vect, dx=dx, dy=dy,
                             cmap=cmap, vmin=vmin, vmax=vmax)
        ax.add_collection(p)
    else:
        p = ax.contourf(X, Y, vect.reshape(X.shape), levels,
                        vmin=vmin, vmax=vmax, cmap=cmap)
    
    # Add colorbar
    cbar = plt.colorbar(p)
    ax.set_xlim(X[0].min(), X[0].max())
    ax.set_ylim(Y[:, 0].min(), Y[:, 0].max())
    ax.set_xlabel(xlabel, fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)

    return fig


def plot3D(X, Y, Z, vectOrig=None, mask=None,
           xlabel=r'$x$', ylabel=r'$y$', zlabel='$z$',
           alpha=0., scattersize=12, cmap=cm.RdBu_r, positive=False,
           xlim=None, ylim=None, zlim=None, plotcbar=True):
    
    if len(X.shape) > 1:
        coord = (X.flatten(), Y.flatten(), Z.flatten())
    else:
        coord = (X, Y, Z)
        
    if mask is not None:
        N = mask.shape[0]
        coord = (coord[0][mask < N],
                 coord[1][mask < N],
                 coord[2][mask < N])
    
    fig = plt.figure()
    ax = fig.gca(projection='3d')
    if vectOrig is not None:
        vect = vectOrig.copy()
        if len(vect.shape) > 1:
            vect = vect.flatten()
        if positive:
            vect /= vect.sum()
        vecAlpha = vect[vect != 0]
        if alpha > 1.e-6:
            if positive:
                vmax = np.sort(vecAlpha)[int((1. - alpha) \
                                             * vecAlpha.shape[0])-1]
                vmin = 0.
            else:
                vmax = np.sort(np.abs(vecAlpha))[int((1. - 2*alpha) \
                                                     * vecAlpha.shape[0])-1]
                vmin = -vmax
            vect[vect > vmax] = vmax
            vect[vect < vmin] = vmin
        else:
            if positive:
                vmax = np.max(vect)
                vmin = 0.
            else:
                vmax = np.max(np.abs(vect))
                vmin = -vmax
        if not positive:
            vect /= np.abs(vmax)
            vmax /= np.abs(vmax)
            vmin /= np.abs(vmin)
        sizes = (np.log10(np.abs(vect) / vmax \
                          * 10**scattersize) + 0.1).astype(int)
        sizes[sizes < 0] = 0
        colors = vect.copy()
        lmin = '< %.2f' % vmin
        lmax = '> %.2f' % vmax
        if not positive:
            if np.abs(colors.max() / colors.min()) > 1:
                lmin = '%.2f' % colors.min()
                colors[colors < 0] *= np.abs(colors.max() / colors.min())
            else:
                lmax = '%.2f' % colors.max()
                colors[colors > 0] *= np.abs(colors.min() / colors.max())
        colors[sizes == 0] = np.nan
        scat = ax.scatter(coord[0], coord[1], coord[2], s=sizes,
                          c=colors, cmap=cmap, vmin=vmin, vmax=vmax,
                          linewidth=0)
        if plotcbar:
            cbar = plt.colorbar(scat)
            if not positive:
                cbar.set_ticks([-1, 0, 1])
                cbar.ax.set_yticklabels([lmin, '0', lmax])
            plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
    else:
        scat = ax.scatter(coord[0], coord[1], coord[2],
                          s=scattersize, linewidth=0)

    if xlim is not None:
        ax.set_xlim(xlim[0], xlim[1])
    if ylim is not None:
        ax.set_ylim(ylim[0], ylim[1])
    if zlim is not None:
        ax.set_zlim(zlim[0], zlim[1])
    ax.set_xlabel(xlabel, fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    ax.set_zlabel(zlabel, fontsize=fs_latex)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)
    plt.setp(ax.get_zticklabels(), fontsize=fs_zticklabels)

    return fig


def plotEigVecPolar(Xt, Yt, vectOrig, mask=None, xlabel=r'$x$', ylabel=r'y',
                    ampMin=None, ampMax=None, nlevAmp=None, csfilter=1,
                    csfmt='%1.3f', alpha=0., cmap=cm.RdBu_r, combine=True):
    figPhase = plt.figure()
    axPhase = figPhase.add_subplot(111)
    
    # Get amplitude and phase
    amp = np.abs(vectOrig)
    phase = np.angle(vectOrig)
    ampAlpha = amp[amp != 0]
    if ampMin is None:
        if alpha > 1.e-6:
            ampMin = np.sort(ampAlpha)[int(alpha * ampAlpha.shape[0])-1]
        else:
            ampMin = np.min(amp)
    if ampMax is None:
        if alpha > 1.e-6:
            ampMax = np.sort(ampAlpha)[int((1. - alpha) \
                                           * ampAlpha.shape[0])-1]
        else:
            ampMax = np.max(amp)
    if np.any(amp < ampMin):
        amp[amp < ampMin] = ampMin
    if np.any(amp > ampMax):
        amp[amp > ampMax] = ampMax
    if nlevAmp is None:
        nlevAmp = levelsAmp

    (X, Y) = (Xt.T, Yt.T)
    N = np.prod(X.shape)
    if mask is not None:
        (dx, dy) = (X[0, 1] - X[0, 0], Y[1, 0] - Y[0, 0])
        coord = (Xt.flatten()[mask < N], Yt.flatten()[mask < N])
        p = pcolor_rectangle(coord[0], coord[1], phase,
                             dx=dx, dy=dy, vmin=-np.pi, vmax=np.pi,
                             cmap=cmap)
        axPhase.add_collection(p)
    else:
        p = axPhase.contourf(X, Y, phase.reshape(X.shape), levelsPhase,
                             cmap=cmap)
    cbar = plt.colorbar(p)
    axPhase.set_xlim(X[0].min(), X[0].max())
    axPhase.set_ylim(Y[:, 0].min(), Y[:, 0].max())
    plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
    cbar.set_ticks(np.arange(-np.pi, np.pi*1.1, np.pi / 2))
    cbar.set_ticklabels([r'$-\pi$', r'$-\pi/2$', r'$0$',
                         r'$\pi/2$', r'$\pi$'])
    axPhase.set_xlabel(xlabel, fontsize=fs_latex)
    axPhase.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
    plt.setp(axPhase.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(axPhase.get_yticklabels(), fontsize=fs_yticklabels)

    ret = (figPhase,)
    if combine:
        if mask is None:
            amp2d = amp
        else:
            amp2d = np.zeros((N,))
            amp2d[mask < N] = amp
            amp2d = amp2d.reshape(X.shape).T
        lvls = np.linspace(ampMin, ampMax, nlevAmp)
        cs = axPhase.contour(X, Y, amp2d, lvls, colors='k',
                             linestyles='-', linewidths=1,
                             vmin=ampMin, vmax=ampMax)
        for k in np.arange(10):
            filterContours(cs, threshold=csfilter)
        axPhase.clabel(cs, inline=1, fontsize=fs_clabel, fmt=csfmt)
    else:
        figAmp = plt.figure()
        axAmp = figAmp.add_subplot(111)
        if mask is None:
            p = axAmp.contourf(X, Y, amp.reshape(X.shape), levelsAmp,
                               cmap=cmap, vmin=ampMin, vmax=ampMax)
        else:
            p = pcolor_rectangle(coord[0], coord[1], amp, dx=dx, dy=dy,
                                 cmap=cmap, vmin=ampMin, vmax=ampMax)
            axAmp.add_collection(p)
        cbar = plt.colorbar(p)
        axAmp.set_xlim(X[0].min(), X[0].max())
        axAmp.set_ylim(Y[:, 0].min(), Y[:, 0].max())
        plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
        axAmp.set_xlabel(xlabel, fontsize=fs_latex)
        axAmp.set_ylabel(ylabel, fontsize=fs_latex)
        plt.setp(cbar.ax.get_yticklabels(), fontsize=fs_yticklabels)
        plt.setp(axAmp.get_xticklabels(), fontsize=fs_xticklabels)
        plt.setp(axAmp.get_yticklabels(), fontsize=fs_yticklabels)
        ret += (figAmp,)

    return ret

def readGrid(gridFile, dimObs):
    """Read transfer operator grid."""
    gfp = open(gridFile, 'r')
    bounds = []
    coord = []
    for k in np.arange(dimObs):
        bounds.append(np.array(gfp.readline().split()).astype(float))
        coord.append((bounds[k][1:] + bounds[k][:-1]) / 2)
    gfp.close()

    return coord


def plotCCF(ccf, lags=None, ls='-', lc='k', lw=2, xlim=None, ylim=None,
            xlabel=None, ylabel=None, absUnit='', plotPositive=False):
    '''Default plot for a correlation function.'''
    if lags is None:
        lags = np.arange(ccf.shape[0])
    if plotPositive:
        nLags = lags.shape[0]
        lags = lags[(nLags - 1) // 2:]
        ccf = ccf[(nLags - 1) // 2:]
    if xlim is None:
        xlim = (lags[0], lags[-1])
    if ylim is None:
        ccfMinMax = np.max(np.abs([ccf.min(), ccf.max()]))
        ylim = (-ccfMinMax, ccfMinMax)
    if absUnit != '':
        absUnit = '(%s)' % absUnit
    if xlabel is None:
        xlabel = r'$t$ %s' % absUnit
    if ylabel is None:
        ylabel = r'$C_{x, x}(t)$'
        
    fig = plt.figure()
    ax = fig.add_subplot(111)
    plt.plot(lags, ccf, linestyle=ls, color=lc, linewidth=lw)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(xlabel, fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)

    return (fig, ax)


def plotPerio(perio, freq=None, perioSTD=None, xlim=None, ylim=None,
              xlabel=None, ylabel=None, xscale='linear', yscale='linear',
              absUnit='', absType='ang', ls='-', lc='k', lw=2,
              fc=None, ec=None, alpha=0.2, plotPositive=False):
    '''Default plot for a periodogram.'''
    nfft = perio.shape[0]
    if freq is None:
        freq = np.arange(-nfft, nfft+1)
    if plotPositive:
        freq = freq[nfft // 2 + 1:]
        perio = perio[nfft // 2 + 1:]
        if perioSTD is not None:
            perioSTD = perioSTD[nfft // 2 + 1:]
    if xlim is None:
        xlim = (freq[0], freq[-1])
    if ylim is None:
        ylim = (perio.min(), perio.max())
    if absType == 'ang':
        absName = '\omega'
        absUnit = 'rad %s' % absUnit
    elif absType == 'freq':
        absName = 'f'
        absUnit = '%s' % absUnit
    if ylabel is None:
        ylabel = r'$\hat{S}_{x,x}(%s)$' % absName
    if absUnit != '':
        absUnit = '(%s)' % absUnit
    if fc is None:
        fc = lc
    if ec is None:
        ec = fc
    
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    if perioSTD is not None:
        perioDown = perio - perioSTD / 2
        perioUp = perio + perioSTD / 2
        ax.fill_between(freq, perioDown, perioUp,
                        facecolor=fc, alpha=alpha, edgecolor=fc)
    ax.plot(freq, perio, linestyle=ls, color=lc, linewidth=lw)
    ax.set_xscale(xscale)
    ax.set_yscale(yscale)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(r'$%s$ %s' % (absName, absUnit),
                  fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)

    return (fig, ax)

def plotRecCorrelation(lags, corrSample, corrRec, corrAna=None,
                       lw=2, xlim=None, ylim=None,
                       xlabel=None, ylabel=None, absUnit='',
                       plotPositive=False):
    """Plot the spectral reconstruction corrRec of the correlation \
    and compare with the sample correlation function corrSample."""
    if plotPositive:
        nLags = lags.shape[0]
        lags = lags[(nLags - 1) // 2:]
        corrSample = corrSample[(nLags - 1) // 2:]
        corrRec = corrRec[(nLags - 1) // 2:]
        if corrAna is not None:
            corrAna = corrAna[(nLags - 1) // 2:]
    if xlim is None:
        xlim = (lags[0], lags[-1])
    if ylim is None:
        corrMax = np.max([np.max(np.abs(corrSample)), np.max(np.abs(corrRec))])
        ylim = (-corrMax, corrMax)
    if absUnit != '':
        absUnit = '(%s)' % absUnit
    if xlabel is None:
        xlabel = r'$t$ %s' % absUnit
    if ylabel is None:
        ylabel = r'$C_{x, x}(t)$'
        
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.plot(lags, corrSample, linestyle='-', color='k', linewidth=lw)
    if corrAna is not None:
        ax.plot(lags, corrAna, linestyle='-', color='b', linewidth=lw)
    ax.plot(lags, corrRec, linestyle='--', color='r', linewidth=lw)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(xlabel, fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)

    return fig

def plotRecCorrelationComponents(lags, compCorrRec, corrRec=None,
                                 n=None, plotPositive=True,
                                 ylabel=None, xlabel=None,
                                 lw=2, xlim=None, ylim=None, absUnit='',
                                 addPairs=True):
    """Plot each components of the  spectral reconstruction corrRec \
    of the correlation."""
    if n is not None:
        compCorrRec = compCorrRec[:n]
    else:
        n = compCorrRec.shape[0]
    if plotPositive:
        nLags = lags.shape[0]
        lags = lags[(nLags - 1) // 2:]
        compCorrRec = compCorrRec[:, (nLags - 1) // 2:]
        if corrRec is not None:
            corrRec = corrRec[(nLags - 1) // 2:]
    if xlim is None:
        xlim = (lags[0], lags[-1])
    if ylim is None:
        corrMax = np.max(np.abs(compCorrRec))
        if corrRec is not None:
            corrMax = np.max([corrMax, np.max(np.abs(corrRec))])
        ylim = (-corrMax, corrMax)
    if absUnit != '':
        absUnit = '(%s)' % absUnit
    if xlabel is None:
        xlabel = r'$t$ %s' % absUnit
    if ylabel is None:
        ylabel = r'$C_{x, x}(t)$'
        
    fig = plt.figure()
    ax = fig.add_subplot(111)
    i = 0
    while i < n:
        diff = 1.e10
        if i+1 < n:
            diff = np.mean(np.abs(compCorrRec[i] \
                                  - np.conjugate(compCorrRec[i+1])))
        if addPairs & (diff < 1.e-6):
            ax.plot(lags, (compCorrRec[i] + compCorrRec[i+1]).real,
                    linestyle='-', linewidth=lw)
            i += 1
        else:
            ax.plot(lags, compCorrRec[i].real, linestyle='-', linewidth=lw)
        i += 1
    if corrRec is not None:
        ax.plot(lags, corrRec, linestyle='--', color='r', linewidth=lw)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(xlabel, fontsize=fs_latex)
    ax.set_ylabel(ylabel, fontsize=fs_latex)
    plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)


def plotEig(eigValGen, eigAna=None, markersize=None, condition=None,
                    xlabel=None, ylabel=None, xlim=None, ylim=None,
                    xticks=None, yticks=None, marker='o'):
    if condition is None:
        condition = 'b'
    # Create axis for eigenvalue and power spectrum panels
    fig = plt.figure()
    axEig = fig.add_subplot(111)

    # Plot eigenvalues
    if markersize is not None:
        axEig.scatter(eigValGen.real, eigValGen.imag,
                      s=msize*2, marker='+',
                      c=condition, cmap=cm.Greys_r)
    else:
        markersize=20

    if eigAna is not None:
        axEig.scatter(eigAna.real, eigAna.imag, c='k',
                      s=int(markersize*2.), marker='x')
    axEig.scatter(eigValGen.real, eigValGen.imag,
                  s=markersize, marker=marker, edgecolors='face',
                  c=condition, cmap=cm.Greys_r)
    if xlim is not None:
        axEig.set_xlim(xlim)
    if ylim is not None:
        axEig.set_ylim(ylim)
    if xlabel is None:
        xlabel = r'$\mathrm{Re}(\lambda)$'
    if ylabel is None:
        ylabel = r'$\mathrm{Im}(\lambda)$'
    axEig.set_xlabel(xlabel, fontsize=fs_default)
    axEig.set_ylabel(ylabel, fontsize=fs_default)
    if xticks is not None:
        axEig.set_xticks(xticks)
    if yticks is not None:
        axEig.set_yticks(yticks)
    plt.setp(axEig.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(axEig.get_yticklabels(), fontsize=fs_yticklabels)
    axEig.grid()

    return fig
 
def plotEigPowerRec(angFreq, eigValGen, powerSample, powerRec, powerAna=None,
                    eigAna=None,
                    markersize=None, condition=None,
                    xlabel=None, ylabel=None, zlabel=None,
                    xlim=None, ylim=None, zlim=None,
                    xticks=None, yticks=None, zticks=None):
    if condition is None:
        condition = 'b'
    # Create axis for eigenvalue and power spectrum panels
    nullfmt = plt.NullFormatter()
    left, width = 0.1, 0.6
    bottom, height = 0.1, 0.9
    leftPow = left + width + 0.01
    widthPow = 0.25
    rectEig = [left, bottom, width, height]
    rectPow = [leftPow, bottom, widthPow, height]
    ratio = height / width
    defaultFigHeight = plt.rcParams['figure.figsize'][1]
    fig = plt.figure(figsize=(defaultFigHeight*ratio, defaultFigHeight))
    axEig = plt.axes(rectEig)
    axPow = plt.axes(rectPow)

    # Plot eigenvalues
    if markersize is not None:
        axEig.scatter(eigValGen.real, eigValGen.imag,
                      s=msize*2, marker='+',
                      c=condition, cmap=cm.Greys_r)
    else:
        markersize=20
        axEig.scatter(eigValGen.real, eigValGen.imag,
                      s=markersize, marker='o', edgecolors='face',
                      c=condition, cmap=cm.Greys_r)
    if eigAna is not None:
        axEig.scatter(eigAna.real, eigAna.imag, c='k',
                      s=int(markersize*2.), marker='x')
    if xlim is not None:
        axEig.set_xlim(xlim)
    if ylim is not None:
        axEig.set_ylim(ylim)
    axEig.set_xlabel(xlabel, fontsize=fs_default)
    axEig.set_ylabel(ylabel, fontsize=fs_default)
    if xticks is not None:
        axEig.set_xticks(xticks)
    if yticks is not None:
        axEig.set_yticks(yticks)
    plt.setp(axEig.get_xticklabels(), fontsize=fs_xticklabels)
    plt.setp(axEig.get_yticklabels(), fontsize=fs_yticklabels)
    axEig.grid()

    # Plot power spectra
    axPow.plot(powerSample, angFreq, 'k-')
    if powerAna is not None:
        axPow.plot(powerAna, angFreq, 'b-')
    axPow.plot(powerRec, angFreq, '--r', linewidth=2)
    axPow.set_xscale('log')
    if zlim is not None:
        axPow.set_xlim(zlim)
    if ylim is not None:
        axPow.set_ylim(ylim)
    axPow.set_xlabel(zlabel, fontsize=fs_default)
    axPow.yaxis.set_major_formatter(nullfmt)
    if yticks is not None:
        axPow.set_yticks(yticks)
    if zticks is not None:
        axPow.set_xticks(zticks)
    elif zlim is not None:
        zticks = np.logspace(np.log10(zlim[0]), np.log10(zlim[1]),
                         int(np.round(np.log10(zlim[1]/zlim[0]) + 1)))
        axPow.set_xticks(zticks)
    zticklabels = ['']
    for k in np.arange(1, zticks.shape[0]):
        zticklabels.append(r'$10^{%d}$' % int(np.round(np.log10(zticks[k]))))
    axPow.set_xticklabels(zticklabels)
    plt.setp(axPow.get_xticklabels(), fontsize='large')
    plt.minorticks_off()
    axPow.grid()
 
    # iFirst = np.abs(eigVal.imag / eigVal.real) \
    #          > np.abs(eigVal[1].imag / eigVal[1].real) / 10
    # nPlot = 2*7
    # if ieigVal.sum() < nPlot:
    #     nPlot = ieigVal.sum()
    # eigValtmp = np.empty((nPlot,), dtype=complex)
    # eigValtmp[:np.min([iFirst.sum(), nPlot])] = eigVal[iFirst][:nPlot]
    # if np.sum(iFirst) < nPlot:
    #     eigValtmp[iFirst.sum():] = eigVal[:nPlot-iFirst.sum()]
    # eigVal = eigValtmp
    # for k in np.arange(eigVal.shape[0]):
    #     ax.plot([eigVal[k].real, 0.],
    #             [eigVal[k].imag, eigVal[k].imag],
    #             [zlim[0], zlim[0]],
    #             '--b')
    #     ax.plot([0., 0.],
    #             [eigVal[k].imag, eigVal[k].imag],
    #             [zlim[0],
    #              powerSamplePlot[np.argmin(np.abs(angFreq - eigVal[k].imag))]],
    #             '--b')
    # if np.sum(~iFirst) > 1:
    #     ax.plot([eigValGen[ieigVal][~iFirst][1].real, 0.],
    #             [eigValGen[ieigVal][~iFirst][1].imag,
    #              eigValGen[ieigVal][~iFirst][1].imag],
    #             [zlim[0], zlim[0]], '--g')
    #     ax.plot([0, 0.], [eigValGen[ieigVal][~iFirst][1].imag,
    #              eigValGen[ieigVal][~iFirst][1].imag],
    #             [zlim[0], powerSamplePlot[np.argmin(np.abs(angFreq - eigValGen[ieigVal][~iFirst][1].imag))]], '--g')

    return fig
    

def plotEigPowerRec3D(angFreq, eigValGen, weights, powerSample, powerRec,
                      xlabel=None, ylabel=None, zlabel=None,
                      xlim=None, ylim=None, zlim=None):
    zlim = np.log10(zlim)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ieigVal = (eigValGen.real >= xlim[0]) \
              & (eigValGen.real <= xlim[1]) \
              & (eigValGen.imag >= ylim[0]) \
              & (eigValGen.imag <= ylim[1])
    ax.scatter(eigValGen[ieigVal].real, eigValGen[ieigVal].imag,
               np.ones((eigValGen[ieigVal].shape[0],)) * zlim[0],
               c='k', s=msize*2, marker='+', depthshade=False)
    ax.scatter(eigValGen[ieigVal].real, eigValGen[ieigVal].imag,
               np.ones((eigValGen[ieigVal].shape[0],)) * zlim[0],
               s=weights,
               c='b', edgecolors='face', marker='o', depthshade=False)
    ax.set_xlim3d(xlim)
    ax.set_ylim3d(ylim)
    ax.set_zlim3d(zlim)
    iangFreq = (angFreq >= ylim[0]) & (angFreq <= ylim[1])
    powerSamplePlot = np.ones((powerSample.shape[0],)) * zlim[0]
    powerRecPlot = np.ones((powerRec.shape[0],)) * zlim[0]
    powerSamplePlot[powerSample > 0] = np.log10(powerSample[powerSample > 0])
    powerRecPlot[powerRec > 0] = np.log10(powerRec[powerRec > 0])
    #powerSamplePlot = powerSample
    powerSamplePlot[powerSamplePlot < zlim[0]] = zlim[0]
    powerSamplePlot[powerSamplePlot > zlim[1]] = zlim[1]
    powerRecPlot[powerRecPlot < zlim[0]] = zlim[0]
    powerRecPlot[powerRecPlot > zlim[1]] = zlim[1]
    ax.plot(np.zeros((iangFreq.sum(),)), angFreq[iangFreq],
            powerSamplePlot[iangFreq], 'k-')
    ax.plot(np.zeros((iangFreq.sum(),)), angFreq[iangFreq],
            powerRecPlot[iangFreq], '-r', linewidth=2)


    eigValPlot = eigValGen[ieigVal]
    iFirst = np.abs(eigValPlot.imag / eigValPlot.real) \
             > np.abs(eigValPlot[1].imag / eigValPlot[1].real) / 10
    nPlot = 2*7
    if ieigVal.sum() < nPlot:
        nPlot = ieigVal.sum()
    eigValPlottmp = np.empty((nPlot,), dtype=complex)
    eigValPlottmp[:np.min([iFirst.sum(), nPlot])] = eigValPlot[iFirst][:nPlot]
    if np.sum(iFirst) < nPlot:
        eigValPlottmp[iFirst.sum():] = eigValPlot[:nPlot-iFirst.sum()]
    eigValPlot = eigValPlottmp
    for k in np.arange(eigValPlot.shape[0]):
        ax.plot([eigValPlot[k].real, 0.],
                [eigValPlot[k].imag, eigValPlot[k].imag],
                [zlim[0], zlim[0]],
                '--b')
        ax.plot([0., 0.],
                [eigValPlot[k].imag, eigValPlot[k].imag],
                [zlim[0],
                 powerSamplePlot[np.argmin(np.abs(angFreq - eigValPlot[k].imag))]],
                '--b')
    if np.sum(~iFirst) > 1:
        ax.plot([eigValGen[ieigVal][~iFirst][1].real, 0.],
                [eigValGen[ieigVal][~iFirst][1].imag,
                 eigValGen[ieigVal][~iFirst][1].imag],
                [zlim[0], zlim[0]], '--g')
        ax.plot([0, 0.], [eigValGen[ieigVal][~iFirst][1].imag,
                 eigValGen[ieigVal][~iFirst][1].imag],
                [zlim[0], powerSamplePlot[np.argmin(np.abs(angFreq - eigValGen[ieigVal][~iFirst][1].imag))]], '--g')
    ax.set_xlabel('\n' + xlabel, fontsize=fs_default,
                  linespacing=1.5)
    ax.set_ylabel('\n' + ylabel, fontsize=fs_default,
                  linespacing=1)
    ax.set_zlabel(zlabel, fontsize=fs_default)
    ax.set_xticks(np.arange(0., xlim[0], (xlim[0]-0.)/5))[::-1]
    zticks = np.arange(zlim[0], zlim[1], 2)
    ax.set_zticks(zticks)
    zticklabels = []
    for k in np.arange(zticks.shape[0]):
        zticklabels.append(r'$10^{%d}$' % zticks[k])
    ax.set_zticklabels(zticklabels)
    ax.view_init(30, -150)
    #plt.setp(ax.get_xticklabels(), fontsize=fs_xticklabels)
    #plt.setp(ax.get_yticklabels(), fontsize=fs_yticklabels)
    #ax.set_title('%d-time-step spectrum for %s\nSlowest time-scale: %.1f' \
        #    % (tau, srcPostfix, -1. / rate[0]))
    #ax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 0.))
    #ax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 0.))
    #ax.w_zaxis.set_pane_color((1.0, 1.0, 1.0, 0.))
    #ax.grid(False)

def getEigenCondition(eigVecForward, eigVecBackward, density=None):
    """ Return a vector containing the condition vector of each \
    pair of eigenvectors."""
    (nev, N) = eigVecForward.shape
    
    if density is None:
        density = eigVecForward[0].real
        density /= density.sum()
        forwardLebesgue = True
    else:
        forwardLebesgue = False
        
    condition = np.empty((nev,))
    for ev in np.arange(nev):
        if forwardLebesgue:
            densitym1 = np.zeros((density.shape[0],))
            densitym1[density > 0] = 1. / density[density > 0]
            normForward \
                = np.sqrt(np.sum(eigVecForward[ev] * densitym1 \
                                 * np.conjugate(eigVecForward[ev])).real)
            inner = (np.sum(eigVecForward[ev] \
                            * np.conjugate(eigVecBackward[ev]))).real
        else:
            normForward \
                = np.sqrt(np.sum(eigVecForward[ev] * density \
                                 * np.conjugate(eigVecForward[ev])).real)
            inner = (np.sum(eigVecForward[ev] * density \
                            * np.conjugate(eigVecBackward[ev]))).real
        normBackward \
            = np.sqrt(np.sum(eigVecBackward[ev] * density \
                             * np.conjugate(eigVecBackward[ev])).real)

        condition[ev] = np.abs(normForward * normBackward / inner)

    return condition

def loadtxt_complex(file_name, data):
    """ Load data of complex type as a formatted string from file file_name."""
    # Open file
    fp = open(file_name, 'r')
    # Reaad file
    for row in np.arange(data.shape[0]):
        line = fp.readline()
        line = line.replace('+-', '-')
        if data.ndim == 1:
            data[row] = complex(line)
        else:
            line = line.split()
            for col in np.arange(data.shape[1]):
                data[row, col] = complex(line[col])
    # Close file
    fp.close()

def loadtxt_nrows(file_name, nrows, dtype=float):
    """ Read nrows of data type dtype from formatted file file_name."""
    # Open file
    fp = open(file_name, 'r')
    # Read first row
    firstRow = np.array(fp.readline().split()).astype(dtype)
    # Get number of columns for all rows
    ncols = firstRow.shape[0]
    # Create data array
    data = np.empty((nrows, ncols), dtype=dtype)
    # Fill rows
    data[0] = firstRow
    for row in np.arange(1, nrows):
        data[row] = np.array(fp.readline().split()).astype(dtype)
    # Close file
    fp.close()
    
    return data

def intersect(arr1, arr2, comp, tol=0.):
    """Return the indices of common elements \
    according to a comparison rule and to a given tolerance \
    (in absolute value) of two arrays of complex. \
    Only the elements of the first array are saved \
    and duplicates are repeated."""

    idx1 = np.zeros(arr1.shape, dtype=bool)
    idx2 = np.zeros(arr2.shape, dtype=bool)
    for i in np.arange(arr1.size):
        iMulti = np.unravel_index(i, arr1.shape[0])
        for j in np.arange(arr2.size):
            jMulti = np.unravel_index(j, arr2.shape[0])
            if comp(arr1[iMulti], arr2[jMulti]) < tol:
                idx1[iMulti] = True
                idx2[jMulti] = True

    return (idx1, idx2)


def compComplex(a, b):
    """Return the distance between two complex numbers in the complex plane."""
    return np.abs(a - b)


def pcolor_rectangle(x, y, data, dx=None, dy=None,
                     vmin=None, vmax=None, cmap=None, ncolors=256,
                     norm=None):
    """Draw color boxes on unstructured grid."""
    if dx is None:
        dx = x[1] - x[0]
    if dy is None:
        dy = y[1] - y[0]    
    if cmap is None:
        cmap = cm.get_cmap(rcParams['image.cmap'], ncolors)
    N = x.shape[0]
    patch = []
    for k in range(N):
        rect = patches.Rectangle((x[k] - dx / 2., y[k] - dy / 2.), dx, dy)
        patch.append(rect)
    pcollection = PatchCollection(patch, cmap=cmap, edgecolor='none',
                                  norm=norm)
    pcollection.set_array(data)
    pcollection.set_clim(vmin, vmax)
    return pcollection

def filterContours(cs, threshold=1):
    '''By default, do nothing'''
    for level in cs.collections:
        for kp,path in enumerate(level.get_paths()):
            # include test for "smallness" of your choice here:
            # I'm using a simple estimation for the diameter based on the
            #    x and y diameter...
            # (N,2)-shape array of contour line coordinates
            verts = path.vertices
            centroid = np.tile(verts.sum(0) / verts.shape[0],
                               (verts.shape[0], 1))
            dist = np.sqrt(np.sum((verts - centroid)**2, 1))
            distMax = np.max(dist)
            if distMax < threshold:
                del(level.get_paths()[kp])  # no remove() for Path objects:(
