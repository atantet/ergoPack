import numpy as np


def stepEuler(x0, field, p, dt, costate=None):
    '''Calculate a single step of Euler integration, \
    to be added to x0.'''
    return dt * field(x0, p, costate)


def stepRK4(x0, field, p, dt, costate=None):
    '''Calculate a single step of Runge-Kutta 4 integration, \
    to be added to x0.'''
    # Step solution forward
    k1 = field(x0, p, costate) * dt
    tmp = k1 * 0.5 + x0
    
    k2 = field(tmp, p, costate) * dt
    tmp = k2 * 0.5 + x0
    
    k3 = field(tmp, p, costate) * dt
    tmp = k3 + x0

    k4 = field(tmp, p, costate) * dt
    tmp = (k1 + 2*k2 + 2*k3 + k4) / 6
    
    return tmp


def propagate(x0, field, p, scheme, dt, nt):
    '''Propagate forward the solution of ODE according to \
    the vector field field with a numerical scheme scheme \
    from x0 for nt time steps of size dt.'''
    xt = np.empty((nt + 1, x0.shape[0]))
    xt[0] = x0.copy()
    for t in np.arange(1, nt + 1):
        xt[t] = xt[t-1] + scheme(xt[t-1], field, p, dt)
        
    return xt

def propagateFundamental(x0, field, JacField, p, scheme, dt, nt):
    '''Propagate forward the solution and fundamental matrix M(0, t) \
    of an ODE according to the vector field field with Jacobian JacField \
    with a numerical scheme scheme from x0 and for nt time steps \
    of size dt.'''
    dim = x0.shape[0]
    xt = np.empty((nt + 1, dim))
    Mt = np.empty((nt + 1, dim, dim))
    xt[0] = x0.copy()
    Mt[0] = np.eye(dim)
    for t in np.arange(1, nt + 1):
        xt[t] = xt[t-1] + scheme(xt[t-1], field, p, dt)
        for d in np.arange(dim):
            Mt[t, :, d] = Mt[t - 1, :, d] \
                          + scheme(Mt[t - 1, :, d], JacField, p, dt, xt[t-1])
        
    return (xt, Mt)

def propagateFundamentalRange(x0, field, JacField, p, scheme, dt, nt):
    '''Propagate forward the solution and fundamental matrix M(s, T) \
    of an ODE according to the vector field field with Jacobian JacField \
    with a numerical scheme scheme from x0 and for nt time steps \
    of size dt.'''
    dim = x0.shape[0]
    xt = np.empty((nt + 1, dim))
    Mt = np.empty((nt + 1, dim, dim))
    step = np.empty((dim, dim))

    # Initialize
    xt[0] = x0.copy()
    Mt[0] = np.eye(dim)

    # Integrate
    for r in np.arange(1, nt + 1):
        # Initialize fundamental matrix Mtr
        Mt[r] = np.eye(dim)
        # Propagate state forward from x0
        xt[r] = xt[r-1] + scheme(xt[r-1], field, p, dt)
        # Get matrix of step r * dt
        for d in np.arange(dim):
            step[:, d] = scheme(Mt[0, :, d], JacField, p, dt, xt[r - 1])
        # Add to Mttau with tau < r
        for tau in np.arange(0, r):
            Mt[tau] += step
            
    return (xt, Mt)

def getPeriod(xt, step=1):
    # Check for fixed point
    if np.sum((xt[-2] - xt[-1])**2) < 1.e-8:
        T, dist0 = 0., 0.
    else:
        nt = xt.shape[0]
        dist0 = np.sum((xt - xt)**2) / nt
        distp1 = np.sum((xt[step:] - xt[:-step])**2) / (nt - step)
        for t in np.arange(1, nt-step):
            distm1 = dist0
            dist0 = distp1
            distp1 = np.sum((xt[t+step:] - xt[:-(t+step)])**2) \
                     / (nt - (t+step))
            if (dist0 < distm1) & (dist0 < distp1):
                break
        T = t
    
    return (T, dist0)



