<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ergoPack: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ergoPack
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Transfer operator analysis from time series and more</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The main purpose of ergoPack is to study the mixing properties of high-dimensional (random) dynamical systems in terms of the spectrum of reduced transfer operators. However, it also includes modules to generate time series of typical systems such as normal forms of codimension one bifurcations, low-dimensional chaotic flows, stochastic processes and delayed systems. These time series can then be used to estimate tranfer operators as in the present tutorial.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Give references to formulas in articles for a precise definition of the transition matrices.</dd></dl>
<h1><a class="anchor" id="tutoSimulating"></a>
Simulating</h1>
<p>ergoPack includes three headers to generate time series of ordinary, stochastic and delay differential equations:</p><ul>
<li><a class="el" href="_o_d_e_solvers_8hpp.html" title="Solve Ordinary Differential Equations. ">ODESolvers.hpp</a>: for the integration of Ordinary Differential Equations (ODEs). Also includes some base clases used by the other headers.</li>
<li><a class="el" href="_s_d_e_solvers_8hpp.html" title="Solve Stocahstic Differential Equations. ">SDESolvers.hpp</a>: for the integration of Stochastic Differential Equations (SDEs).</li>
<li><a class="el" href="_s_d_d_e_solvers_8hpp.html" title="Solve Stochastic Delay Differential Equations. ">SDDESolvers.hpp</a>: for the integration of (Stochastic) Delay Differential Equations (SDDEs).</li>
</ul>
<p>These headers use C++ polymorphism making them as modular as possible. To integrate a given system, one defines a model with a vector field for the drift (possibly including delays), a stochastic vector field for the diffusion and a finite-difference numerical scheme.</p>
<p>Examples of simulations to be found in the "simulation/" folder will now be presented. </p><pre class="fragment">cd ergoPack/simulation/
</pre><h2><a class="anchor" id="tutoODE"></a>
ODE example: the Lorenz flow (Lorenz 1963)</h2>
<p>The code <a class="el" href="sim_lorenz63_8cpp.html" title="Simulate Lorenz (1963) deterministic flow. ">simLorenz63.cpp</a> simulates time series of a Runge-Kutta 4 approximation of the Lorenz 1963 flow. Simulations of ODEs in ergoPack are performed by constructing a <a class="el" href="classmodel.html">model</a> object with a <a class="el" href="classvector_field.html" title="Abstract class defining a vector field. ">vectorField</a>, a <a class="el" href="classnumerical_scheme.html" title="Abstract defining a deterministic numerical scheme. ">numericalScheme</a> and an initial state. Classes to design an ODE are found <a class="el" href="_o_d_e_solvers_8hpp.html" title="Solve Ordinary Differential Equations. ">ODESolvers.hpp</a>, which should be included as such: </p><pre class="fragment">#include &lt;ODESolvers.hpp&gt;
</pre><p>First, the configuration file is parsed (see <a class="el" href="tuto.html#tutoConfig">Using libconfig to parse configuration files</a>). Then, the object corresponding to the Lorenz vector field is created: </p><pre class="fragment">vectorField *field = new Lorenz63(rho, sigma, beta);
</pre><p>Here, the constructor of a <a class="el" href="class_lorenz63.html" title="Vector field for the Lorenz 63 model. ">Lorenz63</a> object with standard parameters is called and assigned to an object of the abstract class <a class="el" href="classvector_field.html" title="Abstract class defining a vector field. ">vectorField</a>. The implementation of such abstract class allows to build a model in a very flexible way as every <a class="el" href="classvector_field.html" title="Abstract class defining a vector field. ">vectorField</a> defines a member <a class="el" href="classvector_field.html#ac306685c4efd8e7053003d5573182909" title="Evaluate the vector field at a given state. ">vectorField::evalField</a> allowing to evaluate the vector field at a given state. Several classical vector fields have been developped in <a class="el" href="_o_d_e_solvers_8hpp.html" title="Solve Ordinary Differential Equations. ">ODESolvers.hpp</a>, <a class="el" href="_s_d_e_solvers_8hpp.html" title="Solve Stocahstic Differential Equations. ">SDESolvers.hpp</a> and <a class="el" href="_s_d_d_e_solvers_8hpp.html" title="Solve Stochastic Delay Differential Equations. ">SDDESolvers.hpp</a>.</p>
<p>The next step is to set a numerical scheme with the object <a class="el" href="classnumerical_scheme.html" title="Abstract defining a deterministic numerical scheme. ">numericalScheme</a>: </p><pre class="fragment">numericalScheme *scheme = new RungeKutta4(dim, dt);
</pre><p>There, we are setting the Runge-Kutta 4 numerical scheme by calling the constructor of the <a class="el" href="class_runge_kutta4.html" title="Runge-Kutta 4 scheme for numerical integration. ">RungeKutta4</a> object with the problem dimension (3 here) and the time step of integration. Every numerical scheme implements a method <a class="el" href="classnumerical_scheme.html#ac14b67551b8236e9aee610fc9c7ba50b" title="Integrate the model one step. ">numericalScheme::stepForward</a> which uses the vector field method <a class="el" href="classvector_field.html#ac306685c4efd8e7053003d5573182909" title="Evaluate the vector field at a given state. ">vectorField::evalField</a> to iterate the integration one step forward. Several numerical schemes, deterministic and stochastic, have been developed in <a class="el" href="_o_d_e_solvers_8hpp.html" title="Solve Ordinary Differential Equations. ">ODESolvers.hpp</a>, <a class="el" href="_s_d_e_solvers_8hpp.html" title="Solve Stocahstic Differential Equations. ">SDESolvers.hpp</a> and <a class="el" href="_s_d_d_e_solvers_8hpp.html" title="Solve Stochastic Delay Differential Equations. ">SDDESolvers.hpp</a>.</p>
<p>Then, the <a class="el" href="classmodel.html">model</a> can be defined from the vector field, the numerical scheme and some initial state: </p><pre class="fragment">model *mod = new model(field, scheme, initState);
</pre><p>The initial state should be a pointer to a <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> vector of the dimension of the vector field. See the <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> documentation for more information.</p>
<p>The model having been designed, we are now all set to perform the numerical integration, which is launched by simply calling the model::integrateForward() method of our model mod: </p><pre class="fragment">X = mod-&gt;integrateForward(L, spinup, printStepNum);
</pre><p>This method takes as argument the length of the time series (in time units and not in number of steps), an eventual spinup period to remove from the beginning of the time series and the number of time steps between each record. It integrates the model forward by iteratively calling the numerical scheme method <a class="el" href="classnumerical_scheme.html#ac14b67551b8236e9aee610fc9c7ba50b" title="Integrate the model one step. ">numericalScheme::stepForward</a> and returns a pointer to an allocated gsl_matrix of the size of the time series times the dimension of the model.</p>
<p>Once the integration has been done, the resulting matrix can be saved using standard <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> functions such as: </p><pre class="fragment">gsl_matrix_fwrite(dstStream, X);
</pre><p>for a binary output, or: </p><pre class="fragment">gsl_matrix_fprintf(dstStream, X, "%f");
</pre><p>for formatted output. We are now ready to build a transfer operator from these time series, in section <a class="el" href="tuto.html#tutoTransfer">Building transfer operators from a single time series</a>.</p>
<h2><a class="anchor" id="tutoSDE"></a>
SDE example: a two-dimensional Ornstein-Uhlenbeck process</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Write a tutorial on integrating stochastic differential equations based on the two-dimensional Ornstein-Uhlenbeck code <a class="el" href="sim_o_u_8cpp.html" title="Simulate a multi-dimensional Ornstein-Uhlenbeck process. ">simOU.cpp</a>.</dd></dl>
<h2><a class="anchor" id="tutoSDDE"></a>
SDDE example: the nonlinear delayed oscillator (Suarez &amp; Schopf 1988)</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Write a tutorial on integrating stochastic delay differential equations based <a class="el" href="sim_s_d_d_e_8cpp.html" title="Simulate a Stochastic Delay Differential Equation. ">simSDDE.cpp</a>.</dd></dl>
<h1><a class="anchor" id="tutoTransfer"></a>
Building transfer operators from a single time series</h1>
<p>The code in <a class="el" href="transfer_8cpp.html" title="Get transition matrices and distributions directly from time series. ">transfer.cpp</a> calculates an estimate of a transition matrix approximating a transfer operator from some input time series, thanks to the objects and methods implemented in <a class="el" href="transfer_operator_8hpp.html" title="Calculate discretized approximation of transfer/Koopman operators from time series. ">transferOperator.hpp</a>. The first step is to define a grid of boxes and to assign each realization of some observable to the grid box it belongs to. This is done by creating a grid membership matrix and using objects and functions declared in <a class="el" href="ergo_grid_8hpp.html" title="Various grid definitions used for Galerkin approximation. ">ergoGrid.hpp</a>. Then, transition matrices can be estimated for different transition lags from the grid membership matrix. If the problem is stationary, only the forward transition matrix is estimated, since the backward matrix can be calculated from it. Otherwise, the backward transition matrix is also estimated. This is done by calling methods from a <a class="el" href="classtransfer_operator.html" title="Transfer operator class. ">transferOperator</a> object. Let us now explain step-by-step how this procedure is performed in <a class="el" href="transfer_8cpp.html" title="Get transition matrices and distributions directly from time series. ">transfer.cpp</a>.</p>
<p>After the usual configuration step (see <a class="el" href="tuto.html#tutoConfig">Using libconfig to parse configuration files</a>), the time series are read from a stream using the <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> functions: </p><pre class="fragment">traj = gsl_matrix_alloc(nt0, dim);
gsl_matrix_fread(srcStream, traj);
</pre><p>Then an observable is defined from the time series by choosing which components to include and whether to delay some of them with respect to the others (thus defining an embedding): </p><pre class="fragment">states = gsl_matrix_alloc(nt, (size_t) dimObs);
for (size_t d = 0; d &lt; (size_t) dimObs; d++)
{
  gsl_vector_const_view view 
  = gsl_matrix_const_subcolumn(traj, gsl_vector_uint_get(components, d),
                   embedMax - gsl_vector_uint_get(embedding, d), nt);
  gsl_matrix_set_col(states, d, &amp;view.vector);
}
</pre><p>Next, a regular grid is defined as an object <a class="el" href="class_regular_grid.html" title="Regular grid. ">RegularGrid</a> inheriting from the abstract class <a class="el" href="class_grid.html" title="Grid class. ">Grid</a>: </p><pre class="fragment">grid = new RegularGrid(nx, nSTDLow, nSTDHigh, states);
</pre><p>The constructor used here takes as argument pointers to <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> vectors with size the number of dimensions and giving the number of boxes for each dimension as well as the number of standard deviations to span (allowing for the grid to adapt to the time series). Several constructors have been implemented in <a class="el" href="ergo_grid_8hpp.html" title="Various grid definitions used for Galerkin approximation. ">ergoGrid.hpp</a>. Every grid class deriving from <a class="el" href="class_grid.html" title="Grid class. ">Grid</a> implements a method <a class="el" href="class_grid.html#af656a2e7ff641d7234277dec2a3f94a3" title="Get membership of a state to a box. ">Grid::getBoxMembership</a> giving the index of the box to which a given state belongs.</p>
<p>The grid can then be printed, as it will be used when plotting the eigenvectors: </p><pre class="fragment">grid-&gt;printGrid(gridFileName, "%.12lf", true);
</pre><p>Once the observable and the grid have been defined, a grid membership vector recording indexing the grid box to which each realization belongs: </p><pre class="fragment">gridMemVector = getGridMemVector(states, grid);
</pre><p>Note, that if ergoPack has been compiled with <a href="http://www.openmp.org/" title="OpenMP">OMP</a> support, this method will be run on parallel threads. One can set the number of threads to be ran by setting the environment variable OMP_NUM_THREADS: </p><pre class="fragment">export OMP_NUM_THREADS=4
</pre><p>Having built a membership vector from a single time series, we must now convert it to a membership matrix for a given transition lag with the first column giving the initial box of each realization and the second column giving the box in which the trajectory ended after the lag. This is done by calling the <a class="el" href="ergo_grid_8hpp.html" title="Various grid definitions used for Galerkin approximation. ">ergoGrid.hpp</a> function: </p><pre class="fragment">gridMemMatrix = memVector2memMatrix(gridMemVector, tauNum);
</pre><p>We are now ready to build the transfer operator object <a class="el" href="classtransfer_operator.html" title="Transfer operator class. ">transferOperator</a>: </p><pre class="fragment">transferOp = new transferOperator(gridMemMatrix, N, stationary);
</pre><p>This constructor takes as argument the grid membership matrix, the number of grid boxes and a boolean indicating whether the problem is stationary or not. This object adds a level of abstracting facilitating the reading and writting of the transition matrices and the initial and final distributions as well as the calculation of their spectrum (see section <a class="el" href="tuto.html#tutoSpectrum">Calculating the spectrum</a>). Its members are transferOperator::N and transferOperator::stationary give the dimension of the matrix (NxN) and whether the problem is stationary or not. The forward and backward transition matrices are declared as <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> sparse matrices <a class="el" href="classtransfer_operator.html#a7ca4ff8ffecfd6cc0e468bfc86c58959" title="Forward transition matrix (CRS) ">transferOperator::P</a> and <a class="el" href="classtransfer_operator.html#abd3165954b7eac0105c77698ca222f8f" title="Backward transition matrix (CRS) ">transferOperator::Q</a> (in compressed column format), while the initial and final distributions are declared as pointers to <a href="http://www.gnu.org/software/gsl/" title="GSL - GNU Scientific Library">GSL</a> vectors <a class="el" href="classtransfer_operator.html#a86eb7b598f3d7402077a0b51cfb017be" title="Initial distribution. ">transferOperator::initDist</a> and <a class="el" href="classtransfer_operator.html#a9f00f7090bf211ced99e16605df435c7" title="Final distribution. ">transferOperator::finalDist</a>. Several constructors have been implemented in <a class="el" href="transfer_operator_8hpp.html" title="Calculate discretized approximation of transfer/Koopman operators from time series. ">transferOperator.hpp</a>.</p>
<p>Finally, the transition matrices and stationary distributions can be written to file by calling printing methods of the <a class="el" href="classtransfer_operator.html" title="Transfer operator class. ">transferOperator</a> object: </p><pre class="fragment">transferOp-&gt;printForwardTransition(forwardTransitionFileName, "%.12lf");
transferOp-&gt;printInitDist(initDistFileName, "%.12lf");
transferOp-&gt;printBackwardTransition(backwardTransitionFileName, "%.12lf");
transferOp-&gt;printFinalDist(finalDistFileName, "%.12lf");
</pre><p>Note that printing the final distribution and the backward transition matrix is only relevant if the problem is nonstationary. Once the transition matrices have been estimated, we are ready to calculate their spectrum.</p>
<h1><a class="anchor" id="tutoTransferMulti"></a>
Building transfer operators from many time series</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Write a tutorial on the estimation of transfer operators from multiple trajectories with different initial conditions using the constructor <a class="el" href="classtransfer_operator.html#a86e78e43e40ad99486ab372b93098a44" title="Constructor from initial and final states for a given grid. ">transferOperator::transferOperator(const gsl_matrix *, const gsl_matrix *, const Grid *, const bool)</a>.</dd></dl>
<h1><a class="anchor" id="tutoSpectrum"></a>
Calculating the spectrum</h1>
<p>The code in <a class="el" href="spectrum_8cpp.html" title="Get spectrum of transfer operators. ">spectrum.cpp</a> calculates the spectrum of previously estimated transition matrices (e.g. using <a class="el" href="transfer_8cpp.html" title="Get transition matrices and distributions directly from time series. ">transfer.cpp</a>, section <a class="el" href="tuto.html#tutoTransfer">Building transfer operators from a single time series</a>) using objects and methods implemented in <a class="el" href="transfer_spectrum_8hpp.html" title="Get spectrum of transferOperator using ARPACK++. ">transferSpectrum.hpp</a> and calling the implicitely restarted Arnoldi method implemented in <a href="http://www.caam.rice.edu/software/ARPACK/arpack++.html" title="ARPACK++">ARPACK++</a>. For a given transition lag, a transfer operator is constructed by reading transition matrices and distributions from file. Then a given number of eigenvalues and eigenvectors are calculated for each transition matrix and the results are written to files.</p>
<p>After the usual configuration step (see <a class="el" href="tuto.html#tutoConfig">Using libconfig to parse configuration files</a>), a pointer to a <a class="el" href="classtransfer_operator.html" title="Transfer operator class. ">transferOperator</a> object is allocated: </p><pre class="fragment">transferOp = new transferOperator(N, stationary);
</pre><p>Previously estimated distributions and transition matrices are then read from file: </p><pre class="fragment">transferOp-&gt;scanInitDist(initDistFileName);
transferOp-&gt;scanForwardTransition(forwardTransitionFileName);
transferOp-&gt;scanFinalDist(finalDistFileName);
transferOp-&gt;scanBackwardTransition(backwardTransitionFileName);
</pre><p>If the problem is stationary, the last to lines are not necessary. Then a pointer to an object from the <a class="el" href="classtransfer_spectrum.html" title="Transfer operator spectrum. ">transferSpectrum</a> class is declared: </p><pre class="fragment">transferSpec = new transferSpectrum(nev, transferOp, config);
</pre><p>This constructor takes as argument the number of eigenvalues and eigenvectors to calculate, the <a class="el" href="classtransfer_operator.html" title="Transfer operator class. ">transferOperator</a> object in which are encapsulated the transition matrices and distributions and a <a class="el" href="structconfig_a_r.html" title="Utility structure used to give configuration options to ARPACK++. ">configAR</a> structure to configure <a href="http://www.caam.rice.edu/software/ARPACK/arpack++.html" title="ARPACK++">ARPACK++</a>. If no configuration structure is given, the default one: </p><pre class="fragment">configAR defaultCfgAR = {"LM", 0, 0., 0, NULL, true};
</pre><p>defined in <a class="el" href="transfer_spectrum_8hpp.html" title="Get spectrum of transferOperator using ARPACK++. ">transferSpectrum.hpp</a> is used. The <a class="el" href="classtransfer_spectrum.html" title="Transfer operator spectrum. ">transferSpectrum</a> class adds a level of abstraction, allowing to easily use <a href="http://www.caam.rice.edu/software/ARPACK/arpack++.html" title="ARPACK++">ARPACK++</a> to specifically calculate the spectrum of transition matrices.</p>
<p>Once the <a class="el" href="classtransfer_spectrum.html" title="Transfer operator spectrum. ">transferSpectrum</a> object has been constructed, the spectrum of the forward and backward transition matrices can be calculated: </p><pre class="fragment">transferSpec-&gt;getSpectrumForward();
transferSpec-&gt;getSpectrumBackward();
</pre><p>These two methods call <a href="http://www.caam.rice.edu/software/ARPACK/arpack++.html" title="ARPACK++">ARPACK++</a> methods to calculate the leading eigenvalues and eigenvectors of the transition matrices. It is then possible to call the <a class="el" href="classtransfer_spectrum.html#a2f842bdef9c421af44aa2202111a728c" title="Make set of forward and backward eigenvectors biorthonormal. ">transferSpectrum::makeBiorthonormal</a> method in order to scale and order the eigenvectors of the forward and backward transition matrices as a biorthonormal family: </p><pre class="fragment">transferSpec-&gt;makeBiorthonormal();
</pre><p>Finally, the eigenvalues and eigenvectors can be saved to file: </p><pre class="fragment">transferSpec-&gt;writeSpectrumForward(EigValForwardFileName,
                       EigVecForwardFileName);
transferSpec-&gt;writeSpectrumBackward(EigValBackwardFileName,
                    EigVecBackwardFileName);
</pre><p>The hard part of the job is now done and it only remains to analyse the spectrum and eventually reconstruct correlation functions and power spectra from it (section <a class="el" href="tuto.html#reconstruct">Reconstructing the correlation function and power spectrum</a>).</p>
<h1><a class="anchor" id="reconstruct"></a>
Reconstructing the correlation function and power spectrum</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Write a tutorial on the reconstruction of correlation functions and power spectra from the spectrum of transition matrices.</dd></dl>
<h1><a class="anchor" id="tutoConfig"></a>
Using libconfig to parse configuration files</h1>
<p>All the programs in this tutorial use <a href="http://www.hyperrealm.com/libconfig/" title="Libconfig">libconfig</a> to parse configuration files. The users can of course choose to discard any <a href="http://www.hyperrealm.com/libconfig/" title="Libconfig">libconfig</a> reference and configure themselves the programs. Here is how <a href="http://www.hyperrealm.com/libconfig/" title="Libconfig">libconfig</a> is used in the codes such as <a class="el" href="transfer_8cpp.html" title="Get transition matrices and distributions directly from time series. ">transfer.cpp</a>: The user calls the program with as argument a configuration script </p><pre class="fragment"> ./transfer.out ../cfg/OU2d.cfg
</pre><p>In the main function of the code <a class="el" href="transfer_8cpp.html" title="Get transition matrices and distributions directly from time series. ">transfer.cpp</a>, the function <a class="el" href="sim_s_d_d_e_8cpp.html#aa010785ea3444039793b472da019f4d6" title="User defined function to get parameters from a cfg file using libconfig. ">readConfig()</a> from <a class="el" href="read_config_8hpp.html" title="Routines to parse a configuration file with libconfig++. ">readConfig.hpp</a> is called: </p><pre class="fragment"> readConfig(configFileName);
</pre><p>This is the main function using libconfig to parse a configuration file. This routine has been tailored for the scripts of the examples considered here. The user may develop his own parsing codes instead. The calls to <a href="http://www.hyperrealm.com/libconfig/" title="Libconfig">libconfig</a> used in <a class="el" href="read_config_8hpp.html" title="Routines to parse a configuration file with libconfig++. ">readConfig.hpp</a> are documented in <a href="http://www.hyperrealm.com/libconfig/" title="Libconfig">libconfig</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
